{"version":3,"file":"element.min.js","sources":["../../../../src/app/block/queue/element.js"],"sourcesContent":["import {getCurrentCourseEditor} from \"core_courseformat/courseeditor\";\nimport Ajax from \"core/ajax\";\nimport * as Toast from 'core/toast';\nimport {get_string as getString} from \"core/str\";\n\nexport default class QueueElement {\n    /**\n     * @type {BaseFactory}\n     */\n    #baseFactory;\n\n    /**\n     * @type {BlockElement}\n     */\n    #blockElement;\n\n    /**\n     * @type {HTMLElement}\n     */\n    #element;\n\n    /**\n     * @type {CourseEditor}\n     */\n    #reactive;\n\n    /**\n     * @type {Promise<void>|null}\n     */\n    #loadQueuePromise = null;\n\n    /**\n     * @type {Object|null}\n     */\n    #loadQueueToken = null;\n\n    /**\n     * @type {boolean}\n     */\n    #preventReload = false;\n\n    /**\n     *\n     * @param {BaseFactory} baseFactory\n     * @param {BlockElement} blockElement\n     * @param {HTMLElement} element\n     */\n    constructor(baseFactory, blockElement, element) {\n        this.#baseFactory = baseFactory;\n        this.#blockElement = blockElement;\n        this.#element = element;\n        this.#reactive = getCurrentCourseEditor();\n\n        this.tryReloadQueue(true);\n\n        setInterval(() => {\n            this.tryReloadQueue();\n        }, 4000);\n    }\n\n    /**\n     * @return {NodeListOf<Element>}\n     */\n    getQueueItems() {\n        return this.#element.querySelectorAll('.queue-item');\n    }\n\n    /**\n     * @param {boolean} ignoreQueueItemsCount\n     */\n    tryReloadQueue(ignoreQueueItemsCount = false) {\n        if (ignoreQueueItemsCount === false && this.getQueueItems().length === 0) {\n            return;\n        }\n\n        if (this.#loadQueuePromise !== null) {\n            this.#loadQueuePromise.then(() => {\n                this.tryReloadQueue();\n            }).catch(() => {\n                this.tryReloadQueue();\n            });\n            return;\n        }\n\n        this.#loadQueueToken = {};\n        this.#loadQueuePromise = this.loadQueue(false, this.#loadQueueToken);\n        this.#loadQueuePromise.then(() => {\n            this.#loadQueuePromise = null;\n            this.#loadQueueToken = null;\n        }).catch(() => {\n            this.#loadQueueToken = null;\n            this.#loadQueuePromise = null;\n        });\n    }\n\n    /**\n     * @param {Boolean} showSpinner\n     * @param {Object} token\n     * @return {Promise<void>}\n     */\n    async loadQueue(showSpinner = false, token = {}) {\n        // eslint-disable-next-line no-async-promise-executor\n        return new Promise(async (resolve, reject) => {\n            token.abort = () => {\n                reject();\n            };\n\n            const oldChildren = this.#element.children;\n            const oldQueueItemsCount = this.getQueueItems().length;\n\n            if (showSpinner) {\n                this.#element.innerHTML = '<i class=\"fa fa-spinner\"></i>';\n            }\n\n            const elements = await this.#baseFactory.moodle().template().createElementsFromFragment(\n                'block_sharing_cart',\n                'item_queue',\n                M.cfg.contextid,\n                {}\n            );\n\n            const queueItems = elements.filter((element) => {\n                if (!(element instanceof Element)) {\n                    return false;\n                }\n\n                return element.classList.contains('queue-item');\n            });\n\n            if (oldQueueItemsCount > queueItems.length) {\n                const removedElements = Array.from(oldChildren).filter((element) => {\n                    const correspondingElement = queueItems.find((el) => el.dataset.id === element.dataset.id);\n\n                    return correspondingElement === undefined;\n                });\n\n                const sectionIds = [];\n                removedElements.forEach((element) => {\n                    const sectionId = element.dataset.toSectionId;\n\n                    if (!sectionId) {\n                        return;\n                    }\n\n                    if (sectionIds.indexOf(sectionId) !== -1) {\n                        return;\n                    }\n\n                    sectionIds.push(sectionId);\n                });\n\n                if (sectionIds.length > 0) {\n                    this.#reactive.dispatch('sectionState', sectionIds).then(() => {\n                        Toast.add(getString('you_may_need_to_reload_the_course_warning', 'block_sharing_cart'), {\n                            closeButton: true,\n                            autohide: true,\n                            type: 'warning'\n                        });\n                    });\n                }\n            }\n\n            this.#element.innerHTML = '';\n\n            queueItems.forEach((element) => {\n                const runNowButton = element.querySelector('button.btn');\n\n                if (!runNowButton) {\n                    return;\n                }\n\n                runNowButton.addEventListener('click', () => {\n                    const taskId = element.dataset.id;\n\n                    runNowButton.disabled = true;\n\n                    this.#preventReload = true;\n                    if (this.#loadQueueToken !== null) {\n                        this.#loadQueueToken.abort();\n                    }\n\n                    Ajax.call([{\n                        methodname: 'block_sharing_cart_run_task_now',\n                        args: {\n                            task_id: taskId\n                        }\n                    }]);\n\n                    setTimeout(() => {\n                        this.#preventReload = false;\n                        this.tryReloadQueue(true);\n                    }, 2000);\n                }, {once: true});\n            });\n\n            elements.forEach((element) => {\n                this.#element.appendChild(element);\n            });\n\n            resolve();\n        });\n    }\n}\n"],"names":["constructor","baseFactory","blockElement","element","tryReloadQueue","setInterval","getQueueItems","_classPrivateFieldGet","querySelectorAll","this","length","loadQueue","then","catch","showSpinner","token","Promise","async","resolve","reject","abort","oldChildren","children","oldQueueItemsCount","innerHTML","elements","moodle","template","createElementsFromFragment","M","cfg","contextid","queueItems","filter","Element","classList","contains","removedElements","Array","from","undefined","find","el","dataset","id","sectionIds","forEach","sectionId","toSectionId","indexOf","push","dispatch","Toast","add","closeButton","autohide","type","runNowButton","querySelector","addEventListener","taskId","disabled","call","methodname","args","task_id","setTimeout","once","appendChild"],"mappings":"s9EA+CIA,YAAYC,YAAaC,aAAcC,4WAlBnB,0EAKF,0EAKD,4CASOF,sDACCC,kDACLC,+CACC,gDAEZC,gBAAe,GAEpBC,aAAY,UACHD,mBACN,KAMPE,uBACWC,qCAAcC,iBAAiB,eAM1CJ,kBACkC,+DAAyC,IAAhCK,KAAKH,gBAAgBI,SAI7B,OAA3BH,0FASmB,iDACEE,KAAKE,WAAU,wBAAOF,sEACxBG,MAAK,kDACC,iDACF,SACxBC,OAAM,gDACkB,mDACE,wDAfFD,MAAK,UACnBR,oBACNS,OAAM,UACAT,2CAqBDU,oEAAqBC,6DAAQ,UAElC,IAAIC,SAAQC,MAAOC,QAASC,UAC/BJ,MAAMK,MAAQ,KACVD,gBAGEE,YAAcd,qCAAce,SAC5BC,mBAAqBd,KAAKH,gBAAgBI,OAE5CI,mDACcU,UAAY,uCAGxBC,eAAiBlB,yCAAkBmB,SAASC,WAAWC,2BACzD,qBACA,aACAC,EAAEC,IAAIC,UACN,IAGEC,WAAaP,SAASQ,QAAQ9B,SAC1BA,mBAAmB+B,SAIlB/B,QAAQgC,UAAUC,SAAS,mBAGlCb,mBAAqBS,WAAWtB,OAAQ,OAClC2B,gBAAkBC,MAAMC,KAAKlB,aAAaY,QAAQ9B,cAGpBqC,IAFHR,WAAWS,MAAMC,IAAOA,GAAGC,QAAQC,KAAOzC,QAAQwC,QAAQC,OAKrFC,WAAa,GACnBR,gBAAgBS,SAAS3C,gBACf4C,UAAY5C,QAAQwC,QAAQK,YAE7BD,YAIkC,IAAnCF,WAAWI,QAAQF,YAIvBF,WAAWK,KAAKH,cAGhBF,WAAWnC,OAAS,yCACLyC,SAAS,eAAgBN,YAAYjC,MAAK,KACrDwC,MAAMC,KAAI,mBAAU,4CAA6C,sBAAuB,CACpFC,aAAa,EACbC,UAAU,EACVC,KAAM,oDAMRhC,UAAY,GAE1BQ,WAAWc,SAAS3C,gBACVsD,aAAetD,QAAQuD,cAAc,cAEtCD,cAILA,aAAaE,iBAAiB,SAAS,WAC7BC,OAASzD,QAAQwC,QAAQC,GAE/Ba,aAAaI,UAAW,6CAEF,GACO,OAAzBtD,yFACqBa,sBAGpB0C,KAAK,CAAC,CACPC,WAAY,kCACZC,KAAM,CACFC,QAASL,WAIjBM,YAAW,gDACe,QACjB9D,gBAAe,KACrB,OACJ,CAAC+D,MAAM,OAGd1C,SAASqB,SAAS3C,+CACAiE,YAAYjE,YAG9Be"}